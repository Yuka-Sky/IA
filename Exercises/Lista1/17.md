# 1.7 Solving the N-Puzzle Problem 

The objective of this exercise is the application of search methods, with emphasis on informed search methods and the A* algorithm, to solve the well-known N-Puzzle problem. The desired objective state for the puzzle is as follows (0 represents the empty space): 
```
   9 Puzzle      16 Puzzle 
    1 2 3       1  2  3  4 
    4 5 6       5  6  7  8  
    7 8 0       9 10 11 12 
               13 14 15  0 
```
Starting from a given initial state, the goal is to determine which operations to perform to solve the puzzle, reaching the desired objective state.

## Formulate the problem as a search problem indicating the state representation, operators (their names, preconditions, effects, and cost), initial state, and objective test.
**State Representation**: The state is represented as an N×N grid (3×3 for 9-Puzzle, 4×4 for 16-Puzzle) where each tile has a number, and 0 represents the empty space. \
**Operators (Actions)**:
```
Move Up:    Swap 0 with the tile above it.
Move Down:  Swap 0 with the tile below it.
Move Left:  Swap 0 with the tile to the left.
Move Right: Swap 0 with the tile to the right.
```
- **Preconditions**: The empty space (0) must have a valid neighbor to swap with.
- **Effects**: The puzzle state changes by swapping 0 with the corresponding neighbor.
- **Cost**: In Uniform Cost Search (BFS here), all moves have equal cost (1).
**Initial State**: Will be given as input. \
**Goal State**: The solved configuration:
```
   for 3x3       for 4x4
    1 2 3       1  2  3  4 
    4 5 6       5  6  7  8  
    7 8 0       9 10 11 12 
               13 14 15  0 
```

## Implement code to solve this problem using the “breath-first” strategy (in this case identical to "Uniform Cost").
The code is present on the Npuzzle_prob.py.The main part of BFS consists in:
```
def bfs(initial_state):
    size = len(initial_state)
    goal_state = generate_goal_state(size)
    queue = deque([(initial_state, [], 0)])  # (current state, path, cost)
    visited = set()
    max_memory = 0
    
    while queue:
        max_memory = max(max_memory, len(queue))
        state, path, cost = queue.popleft()
        
        if state == goal_state:
            return path + [state], cost, max_memory
        
        state_tuple = tuple(map(tuple, state))
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        
        for neighbor in get_neighbors(state):
            queue.append((neighbor, path + [state], cost + 1))
    
    return None, None, max_memory
```

## Implement code to solve this problem using Greedy Search and using the A* Algorithm. Suppose the following heuristics for these methods:
### H1 - Number of incorrected placed pieces (Greedy Search):
In the same code, the H1 is made by:
```
def greedy_search(initial_state):
    size = len(initial_state)
    goal_state = generate_goal_state(size)
    priority_queue = [(heuristic_misplaced_tiles(initial_state, goal_state), initial_state, [], 0)]
    visited = set()
    max_memory = 0
    
    while priority_queue:
        max_memory = max(max_memory, len(priority_queue))
        _, state, path, cost = heapq.heappop(priority_queue)
        
        if state == goal_state:
            return path + [state], cost, max_memory
        
        state_tuple = tuple(map(tuple, state))
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        
        for neighbor in get_neighbors(state):
            heapq.heappush(priority_queue, (heuristic_misplaced_tiles(neighbor, goal_state), neighbor, path + [state], cost + 1))
    
    return None, None, max_memory
```
### H2 - Sum of Manhattan distances from incorrected placed pieces to their correct places (A* Algorythm):
The same goes to H2:
```
def a_star(initial_state):
    size = len(initial_state)
    goal_state = generate_goal_state(size)
    priority_queue = [(heuristic_manhattan_distance(initial_state, goal_state), 0, initial_state, [], 0)]
    visited = set()
    max_memory = 0
    
    while priority_queue:
        max_memory = max(max_memory, len(priority_queue))
        _, g, state, path, cost = heapq.heappop(priority_queue)
        
        if state == goal_state:
            return path + [state], cost, max_memory
        
        state_tuple = tuple(map(tuple, state))
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        
        for neighbor in get_neighbors(state):
            new_g = g + 1
            f = new_g + heuristic_manhattan_distance(neighbor, goal_state)
            heapq.heappush(priority_queue, (f, new_g, neighbor, path + [state], cost + 1))
    
    return None, None, max_memory
```

## Compare the results obtained concerning execution time and memory space occupied in solving the following problems using the previous methods:
To better view, it was implemented a main code given as:
```
def main():
    size = int(input("Enter puzzle size (3 for 3x3, 4 for 4x4): "))
    initial_state = []
    print(f"Enter the {size}x{size} initial state row by row, using spaces between numbers:")
    for _ in range(size):
        initial_state.append(list(map(int, input().split())))
    
    algorithms = {"BFS": bfs, "Greedy Search (H1)": greedy_search, "A* (H2)": a_star}
    results = []
    
    for name, algorithm in algorithms.items():
        print(f"\nRunning {name}...")
        start_time = time.time()
        solution, cost, memory = algorithm(initial_state)
        end_time = time.time()
        
        if solution:
            results.append((name, cost, end_time - start_time, memory))
        else:
            results.append((name, "No solution", "-", "-"))
    
    print("\nSummary of Results:")
    print("Method | Cost | Execution Time (s) | Memory Usage")
    print("--------------------------------------------------")
    for name, cost, exec_time, memory in results:
        print(f"{name}: {cost} | {exec_time:.4f} sec | {memory} states")
```

Therefore, we can test the given problems and obtain the next results:
```
Probl1:
  1 2 3
  5 0 6
  4 7 8

Summary of Results:
Method | Cost | Execution Time (s) | Memory Usage
--------------------------------------------------
BFS:                4 | 0.0011 sec | 42 states
Greedy Search (H1): 4 | 0.0002 sec | 9 states
A* (H2):            4 | 0.0002 sec | 9 states

Probl2:
  1 3 6
  5 2 0
  4 7 8

Summary of Results:
Method | Cost | Execution Time (s) | Memory Usage
--------------------------------------------------
BFS:                7 | 0.0031 sec | 138 states
Greedy Search (H1): 7 | 0.0003 sec | 14 states
A* (H2):            7 | 0.0003 sec | 14 states

Prob3:
  1 6 2
  5 7 3
  0 4 8

Summary of Results:
Method | Cost | Execution Time (s) | Memory Usage
--------------------------------------------------
BFS:                10 | 0.0214 sec | 624 states
Greedy Search (H1): 66 | 0.0143 sec | 271 states
A* (H2):            10 | 0.0005 sec | 27 states

Prob4:
  5  1  3  4
  2  0  7  8
 10  6 11 12
  9 13 14 15

Summary of Results:
Method | Cost | Execution Time (s) | Memory Usage
--------------------------------------------------
BFS:                 10 | 0.0872 sec | 7357 states
Greedy Search (H1): 184 | 0.0857 sec | 3035 states
A* (H2):             10 | 0.0005 sec | 33 states
```