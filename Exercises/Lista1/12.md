# 1.2 Missionaries and Cannibals Problem 
Three missionaries and three cannibals are on one of the banks of the river with a boat that only takes one or two people. The boat cannot travel the river alone. The goal is to find a way to get the six to the other bank of the river without ever leaving more cannibals than missionaries on one of the banks (even at the instant they leave/join the boat) during the process. 

## Formulate this problem as a search problem by defining the state representation, initial state, operators (their name, preconditions, effects, and cost), and objective test.
**State Representation**: A state is represented as `(M, C, B)`, where:
- `M` is the number of missionaries on the left bank.
- `C` is the number of cannibals on the left bank.
- `B` indicates the boat’s position (`0` for the left bank, `1` for the right bank).
The number of missionaries and cannibals on the right bank can be inferred as:
- `M_right = 3 - M`
- `C_right = 3 - C`

**Initial State**: `(3,3,0)`: All missionaries and cannibals start on the left bank with the boat.

**Goal State**: `(0,0,1)`: All missionaries and cannibals have safely crossed to the right bank.

**Operators**: The boat can carry one or two people at a time. Possible valid moves are:
1. `(M-2, C, 1-B)` → Two missionaries cross.
2. `(M, C-2, 1-B)` → Two cannibals cross.
3. `(M-1, C-1, 1-B)` → One missionary and one cannibal cross.
4. `(M-1, C, 1-B)` → One missionary crosses.
5. `(M, C-1, 1-B)` → One cannibal crosses.

**Preconditions**: A move is valid if:
- `0 ≤ M ≤ 3` and `0 ≤ C ≤ 3` on both banks.
- The boat is not empty.
- **Missionary safety constraint:** On either bank, missionaries must never be outnumbered by cannibals (`M >= C` whenever `M > 0`).

**Effects**: Each operator updates the number of missionaries and cannibals on the banks and moves the boat.

**Cost Function**: Each action has a uniform cost of `1` (assuming equal effort for each crossing).

**Objective Test**: A state is a goal state if `(M, C, B) = (0,0,1)`, meaning all missionaries and cannibals have successfully crossed the river.

## What is the space state size for this problem? Represent it showing the possible objective states and display some of the possible transitions in the space state from the initial state.  
**State Space Size**: The state space consists of all possible combinations of missionaries (M), cannibals (C), and the boat's position (B). 
- There are 4 possible values for `M` (0, 1, 2, 3) since the number of missionaries can range from 0 to 3.
- There are 4 possible values for `C` (0, 1, 2, 3) for the same reason for cannibals.
- There are 2 possible positions for the boat (`B` = 0 for left bank, `B` = 1 for right bank).

Thus, the total number of states is:
- 4 (M values) × 4 (C values) × 2 (B values) = 32 possible states.
  
**State Space Representation**: Each state can be represented as `(M, C, B)`, where:
- `M` is the number of missionaries on the left bank.
- `C` is the number of cannibals on the left bank.
- `B` is the position of the boat (`0` for left bank, `1` for right bank).

**Objective States**: The goal state is `(0, 0, 1)`, meaning all missionaries and cannibals are on the right bank with the boat.

**Some Possible Transitions**: Here are some of the possible transitions from the initial state `(3, 3, 0)` to various other states:
- **From `(3, 3, 0)` to `(1, 3, 1)`**: Two missionaries cross the river.
- **From `(3, 3, 0)` to `(3, 1, 1)`**: Two cannibals cross the river.
- **From `(3, 3, 0)` to `(2, 2, 1)`**: One missionary and one cannibal cross the river.
- **From `(3, 3, 0)` to `(3, 2, 1)`**: One missionary crosses the river.
- **From `(3, 3, 0)` to `(3, 1, 1)`**: One cannibal crosses the river.

**Transition Diagram**:
- Initial State: `(3, 3, 0)`
  - → `(1, 3, 1)` (2 missionaries cross)
  - → `(3, 1, 1)` (2 cannibals cross)
  - → `(2, 2, 1)` (1 missionary + 1 cannibal cross)
  - → `(3, 2, 1)` (1 missionary crosses)
  - → `(3, 1, 1)` (1 cannibal crosses)
  
- From `(1, 3, 1)`:
  - → `(3, 3, 0)` (2 missionaries cross back)
  - → `(1, 1, 0)` (1 missionary + 1 cannibal cross back)
  
- From `(2, 2, 1)`:
  - → `(3, 3, 0)` (1 missionary + 1 cannibal cross back)
  - → `(1, 2, 0)` (2 missionaries cross back)

## Solve the problem, by hand, using tree search. 
**Initial State: `(3, 3, 0)`**\
At the start, there are 3 missionaries and 3 cannibals on the left bank, with the boat on the left bank.

**Valid moves from `(3, 3, 0)`**:
1. Two missionaries cross: `(1, 3, 1)`
2. Two cannibals cross: `(3, 1, 1)`
3. One missionary and one cannibal cross: `(2, 2, 1)`
4. One missionary crosses: `(2, 3, 1)`
5. One cannibal crosses: `(3, 2, 1)`


**From `(1, 3, 1)` (Move 1)**
1. Two missionaries cross back: `(3, 3, 0)`
2. One missionary and one cannibal cross back: `(2, 3, 0)`
3. One cannibal crosses back: `(1, 2, 0)`

**From `(3, 1, 1)` (Move 2)**
1. Two cannibals cross back: `(3, 3, 0)`
2. One missionary and one cannibal cross back: `(2, 2, 0)`
3. One missionary crosses back: `(2, 1, 0)`

**From `(2, 2, 1)` (Move 3)**
1. Two missionaries cross back: `(3, 2, 0)`
2. Two cannibals cross back: `(2, 3, 0)`
3. One missionary and one cannibal cross back: `(1, 3, 0)`

**From `(2, 3, 1)` (Move 4)**
1. Two missionaries cross back: `(3, 3, 0)`
2. One missionary and one cannibal cross back: `(1, 3, 0)`
3. One cannibal crosses back: `(2, 2, 0)`

**From `(3, 2, 1)` (Move 5)**
1. Two missionaries cross back: `(3, 3, 0)`
2. One missionary and one cannibal cross back: `(2, 3, 0)`
3. One cannibal crosses back: `(3, 1, 0)`

**Goal State: `(0, 0, 1)`** \
We aim to reach this goal state where all missionaries and cannibals are on the right bank, with the boat on the right bank.

## **Final Sequence of Moves**

We backtrack from the goal state `(0, 0, 1)` to the initial state `(3, 3, 0)`:

1. **From `(3, 3, 0)`** (Initial State)
   - Move: One missionary crosses → `(2, 3, 1)`

2. **From `(2, 3, 1)`**
   - Move: One cannibal crosses back → `(2, 2, 0)`

3. **From `(2, 2, 0)`**
   - Move: One missionary crosses → `(1, 2, 1)`

4. **From `(1, 2, 1)`**
   - Move: One cannibal crosses back → `(1, 1, 0)`

5. **From `(1, 1, 0)`**
   - Move: One missionary crosses → `(0, 1, 1)`

6. **From `(0, 1, 1)`**
   - Move: One cannibal crosses back → `(0, 0, 0)`

## **Solution Path**

1. Initial State: `(3, 3, 0)`
2. Move 1: One missionary crosses → `(2, 3, 1)`
3. Move 2: One cannibal crosses back → `(2, 2, 0)`
4. Move 3: One missionary crosses → `(1, 2, 1)`
5. Move 4: One cannibal crosses back → `(1, 1, 0)`
6. Move 5: One missionary crosses → `(0, 1, 1)`
7. Move 6: One cannibal crosses back → `(0, 0, 0)`

Thus, all missionaries and cannibals safely reach the right bank.

## Using a programming language of your choice, solve the problem by applying:
### (BFS) Breadth-first search strategy
```
def bfs(initial_state):
    queue = deque([(initial_state, [])])  # (state, path)
    visited = set()

    while queue:
        state, path = queue.popleft()
        if state in visited:
            continue
        visited.add(state)

        if is_goal_state(state):
            return path + [state]

        for move in possible_moves(state):
            if is_valid_state(move) and move not in visited:
                queue.append((move, path + [state]))

    return None
```
> Consists in exploring all possible states level by level. It uses a queue to manage the states and a visited set to avoid revisiting states. The goal is to find the shortest path to the goal state.
### (DFS) Depth-first search strategy (limited depth);
```
def dfs(initial_state, limit):
    stack = [(initial_state, [], 0)]  # (state, path, depth)
    visited = set()

    while stack:
        state, path, depth = stack.pop()
        if state in visited:
            continue
        visited.add(state)

        if is_goal_state(state):
            return path + [state]

        if depth < limit:
            for move in possible_moves(state):
                if is_valid_state(move) and move not in visited:
                    stack.append((move, path + [state], depth + 1))

    return None

```
> Eexplores the states by going deep into one branch before backtracking. A depth limit is specified, and the search will stop once the depth exceeds this limit. It uses a stack to manage the states.

### (IDDFS) Iterative deepening strategy
```
def iterative_deepening(initial_state):
    depth = 0
    while True:
        result = dfs(initial_state, depth)
        if result is not None:
            return result
        depth += 1
```
> Combines the DFS approach with increasing depth limits. It first tries DFS with a depth limit of 0, then 1, and so on until a solution is found.

The Main idea of other functions in the code `missionCanib_prob.py` is:

1. `possible_moves` function generates all valid moves based on the current state (M, C, B), where M is the number of missionaries on the left bank, C is the number of cannibals on the left bank, and B is the boat's position (0 for left, 1 for right).
2. `is_valid_state` function ensures that the number of missionaries is never less than the number of cannibals on any bank (unless there are no missionaries on that bank), and the values of M and C stay within valid bounds.
3. `is_goal_state` function checks whether all the missionaries and cannibals have crossed to the right bank with the boat, i.e., the state (0, 0, 1).
4. `run_all_strategies` function runs all three search strategies: BFS, DFS, and Iterative Deepening, and prints the results.

Results:
```
BFS Result:
[(3, 3, 0), (3, 1, 1), (3, 2, 0), (3, 0, 1), (3, 1, 0), (1, 1, 1), (2, 1, 0), (0, 1, 1), (1, 1, 0), (0, 0, 1)]

DFS Result (Limit Depth = 10):
[(3, 3, 0), (2, 2, 1), (3, 2, 0), (2, 1, 1), (2, 2, 0), (1, 1, 1), (2, 1, 0), (0, 1, 1), (0, 2, 0), (0, 0, 1)]

Iterative Deepening Result:
[(3, 3, 0), (2, 2, 1), (3, 2, 0), (2, 1, 1), (2, 2, 0), (1, 1, 1), (2, 1, 0), (0, 1, 1), (0, 2, 0), (0, 0, 1)]
```