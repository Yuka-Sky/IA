# 1.1 Two Buckets Problem 
Two buckets of capacities c1 (e.g. 4 liters) and c2 (e.g. 3 liters), respectively, are initially empty.
Buckets do not have any intermediate markings. The only operations you can perform are: 

- Fill (completely) a bucket  
- Empty a bucket. 
- Pour one bucket into the other (until the second one is full or until the first one is empty). 

The aim is to determine which operations to carry out so that the first bucket contains n liters (e.g. 2 litres). 

## Formulate this problem as a search problem by defining the state representation, initial state, operators (their name, preconditions, effects, and cost), and objective test. 

We need to define bucket `capacities` (A = 4L, B = 3L) in a touple `(A, B)`, the `start_state` as both buckets empty and the `goal_amount`, that will be defined by the tester.

```
capacities = (4, 3)  
start_state = (0, 0)  
```
```
while True:
        try:
            goal_amount = int(input(f"Enter the goal amount (0 to {capacities[0]} liters in bucket A): "))
            if 0 <= goal_amount <= capacities[0]:
                break
            else:
                print(f"Invalid input! Enter a number between 0 and {capacities[0]}.")
        except ValueError:
            print("Invalid input! Please enter a valid integer.")
```

## What is the space state size for this problem? Represent it showing the possible objective states and display some of the possible transitions in the space state from the initial state.

The state space consists of all possible states reachable by the operators, which in this case would be 20 since A has 5 possible values (0-4) and B has 4 possible values (0-3), even though not all states are reachable.
If the initial is `(0, 0)`, we can fill eithe bucket A `(4, 0)` or B `(0, 3)`, and pour to the other one, in ther first case `(1, 3)` because the max amount would be 3L, and the second `(3, 0)` because the A has 4L capability, and so on until we acheive the `goal_amount` in the bucket A.

The implementation to acheive this will be given as neighbors of the search tree as:
```
# Function to generate next possible states
def get_neighbors(state, capacities):
    """Returns possible next states from the current state."""
    a, b = state  # Current bucket amounts
    a_max, b_max = capacities  # Bucket capacities

    # Possible moves
    possible_moves = set([
        (a_max, b),   # Fill bucket A
        (a, b_max),   # Fill bucket B
        (0, b),       # Empty bucket A
        (a, 0),       # Empty bucket B
        (max(0, a - (b_max - b)), min(b_max, b + a)),  # Pour A → B
        (min(a_max, a + b), max(0, b - (a_max - a)))   # Pour B → A
    ])
    
    return possible_moves
```

## Solve the problem, by hand, using tree search. 
One of the options could be solved if we:
```
(0, 0) -> (0, 3) -> (3, 0) -> (3, 3) -> (4, 2) -> (0, 2) -> (2, 0)
```
## Using a programming language of your choice, solve the problem by applying the options given in the menu: 
```
Choose an algorithm to solve the Two Buckets Problem:
1. Breadth-First Search (BFS)
2. Depth-First Search (DFS - Limited Depth)
3. Iterative Deepening Depth-First Search (IDDFS)
4. Exit
```
> All of this can be tested by running the `bucket_prob.py`

### (BFS) Breadth-first search strategy. 
```
def bfs(capacities, start, goal_amount):
    """Breadth-First Search to find the shortest solution."""
    queue = deque([(start, [])])  # (current state, path)
    visited = set()

    while queue:
        current_state, path = queue.popleft()

        if current_state in visited:
            continue
        visited.add(current_state)

        if current_state[0] == goal_amount:
            return path + [current_state]  # Solution found

        for neighbor in get_neighbors(current_state, capacities):
            if neighbor not in visited:
                queue.append((neighbor, path + [current_state]))

    return None  # No solution found
```

### (DFS) Depth-first search strategy (limited depth).
```
def dfs_limited(capacities, start, goal_amount, max_depth):
    """Depth-First Search with a depth limit."""
    stack = [(start, [], 0)]  # (current state, path, depth)
    visited = set()

    while stack:
        current_state, path, depth = stack.pop()

        if current_state in visited:
            continue
        visited.add(current_state)

        if current_state[0] == goal_amount:
            return path + [current_state]  # Solution found

        if depth < max_depth:
            for neighbor in get_neighbors(current_state, capacities):
                if neighbor not in visited:
                    stack.append((neighbor, path + [current_state], depth + 1))

    return None  # No solution found within the depth limit
```

### (IDDFS) Iterative deepening strategy. 
IDDFS is a combination of BFS and DFS, therefore we can combine it in the next form:
```
def iddfs(capacities, start, goal_amount, max_depth):
    """Iterative Deepening DFS that increases depth limit gradually."""
    for depth in range(max_depth + 1):
        solution = dfs_limited(capacities, start, goal_amount, depth)
        if solution:
            return solution
    return None
```